# CodegenAnalysis

> ⚠️ The library is in progress (alpha versioning). 
> 
> ⚠️ No expected behaviour, no documentation, no backward compatibility.

![](https://img.shields.io/static/v1?label=Lowest+target&message=netstandard2.0&color=purple&logo=dotnet)

![](https://img.shields.io/static/v1?label=Windows&message=Supported&color=brightgreen&logo=windows)
![](https://img.shields.io/static/v1?label=Linux&message=Supported&color=brightgreen&logo=linux)
![](https://img.shields.io/static/v1?label=MacOS&message=Supported&color=brightgreen&logo=apple)

<img align="right" src="./logo1t.png">

Library for analyzing the machine code generated by JIT (codegen). Has API for obtaining the codegen, verifying the characteristics for tests (in a similar manner to xUnit), and generating reports as benchmarks (in a similar manner to BenchmarkDotNet). Supports x86_64 on three major platforms (Windows, MacOS, Linux).



### Table of contents
- [CodegenAnalysis](#CodegenAnalysis)
- [CodegenAnalysis.Assertions](#CodegenAnalysisAssertions)
- [CodegenAnalysis.Benchmarks](#CodegenAnalysisBenchmarks)

## CodegenAnalysis

[![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/CodegenAnalysis?label=NuGet&logo=nuget)](https://www.nuget.org/packages/CodegenAnalysis)

```cs
static int AddAndMul(int a, int b) => a + b * a;

...

var codegenInfo = CodegenInfoResolver.GetCodegenInfo(CompilationTier.Tier1, () => AddAndMul(3, 5));
Console.WriteLine(codegenInfo);
```
Output:
```assembly
00007FFD752E42F0 8BC2                 mov       eax,edx
00007FFD752E42F2 0FAFC1               imul      eax,ecx
00007FFD752E42F5 03C1                 add       eax,ecx
00007FFD752E42F7 C3                   ret
```

## CodegenAnalysis.Assertions

[![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/CodegenAnalysis.Assertions?label=NuGet&logo=nuget)](https://www.nuget.org/packages/CodegenAnalysis.Assertions)

### Verifying the size of the codegen

```cs
using CodegenAssertions;
using Xunit;

public class CodegenSizeQuickJit
{
    public static int SomeMethod(int a, int b)
        => a + b;

    [Fact]
    public void Test1()
    {
        AssertCodegen.CodegenLessThan(20, CompilationTier.Tier0, () => SomeMethod(4, 5));
    }
}
```


### Having calls in the codegen

```cs
public class Tests
{
    public class A
    {
        public virtual int H => 3;
    }

    public sealed class B : A
    {
        public override int H => 6;
    }

    // this will get devirtualized at tier1, but not at tier0
    static int Twice(B b) => b.H * 2;

    [Fact]
    public void NotDevirtTier0()
    {
        AssertCodegen.CodegenHasCalls(CompilationTier.Tier0, () => Twice(new B()));
    }

    [Fact]
    public void DevirtTier1()
    {
        AssertCodegen.CodegenDoesNotHaveCalls(CompilationTier.Tier1, () => Twice(new B()));
    }
}
```

### Testing if we have branches

```cs
    private static readonly bool True = true;

    static int SmartThing()
    {
        if (True)
            return 5;
        return 10;
    }

    [Fact]
    public void BranchElimination()
    {
        AssertCodegen.CodegenDoesNotHaveBranches(CompilationTier.Tier1, () => SmartThing());
    }

    [MethodImpl(MethodImplOptions.NoOptimization)]
    static int StupidThing()
    {
        if (True)
            return 5;
        return 10;
    }

    [Fact]
    public void NoBranchElimination()
    {
        AssertCodegen.CodegenHasBranches(CompilationTier.Default, () => StupidThing());
    }
```

## CodegenAnalysis.Benchmarks

[![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/CodegenAnalysis.Benchmarks?label=NuGet&logo=nuget)](https://www.nuget.org/packages/CodegenAnalysis.Benchmarks)

```cs
CodegenBenchmarkRunner.Run<A>();

[CAJob(Tier = CompilationTier.Default),
 CAJob(Tier = CompilationTier.Tier1)]

[CAColumn(CAColumn.Branches),
 CAColumn(CAColumn.Calls), 
 CAColumn(CAColumn.CodegenSize), 
 CAColumn(CAColumn.StaticStackAllocations)]

[CAExport(Export.Html),
 CAExport(Export.Md)]
public class A
{
    [CAInput(3.5f)]
    [CAInput(13.5f)]
    public static float Heavy(float a)
    {
        var b = Do1(a);
        var c = Do1(b);
        if (a > 10)
            c += Aaa(a);
        return c + b;
    }

    [CAInput(6f)]
    public static float Square(float a)
    {
        return a * a;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static float Do1(float a)
    {
        return a * 2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static float Aaa(float h)
    {
        return h * h * h;
    }
}
```

The output coming soon...
